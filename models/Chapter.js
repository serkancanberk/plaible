// models/Chapter.js
// Mongoose model for storing story chapters generated by AI

import mongoose from 'mongoose';

const { Schema, model } = mongoose;

const choiceSchema = new Schema(
  {
    text: {
      type: String,
      required: true,
      trim: true
    },
    nextChapterId: {
      type: Schema.Types.ObjectId,
      ref: 'Chapter',
      default: null
    }
  },
  { _id: false }
);

const chapterSchema = new Schema(
  {
    sessionId: {
      type: Schema.Types.ObjectId,
      ref: 'UserStorySession',
      required: true,
      index: true
    },
    chapterIndex: {
      type: Number,
      required: true,
      min: 1,
      index: true
    },
    storyPromptUsed: {
      type: String,
      required: true,
      trim: true
    },
    openingBeat: {
      type: String,
      required: true,
      trim: true
    },
    title: {
      type: String,
      required: true,
      trim: true
    },
    content: {
      type: String,
      required: true,
      trim: true
    },
    choices: {
      type: [choiceSchema],
      default: [],
      validate: {
        validator: function(choices) {
          return choices.length >= 2 && choices.length <= 4; // 2-4 choices per chapter
        },
        message: 'Chapter must have between 2 and 4 choices'
      }
    },
    createdAt: {
      type: Date,
      default: Date.now
    },
    updatedAt: {
      type: Date,
      default: Date.now
    }
  },
  {
    timestamps: true,
    collection: 'chapters'
  }
);

// Compound indexes for efficient queries
chapterSchema.index({ sessionId: 1, chapterIndex: 1 }, { unique: true });
chapterSchema.index({ sessionId: 1, createdAt: -1 });

// Static methods for common queries
chapterSchema.statics.findBySessionId = function(sessionId) {
  return this.find({ sessionId }).sort({ chapterIndex: 1 });
};

chapterSchema.statics.findBySessionAndIndex = function(sessionId, chapterIndex) {
  return this.findOne({ sessionId, chapterIndex });
};

chapterSchema.statics.getLatestChapter = function(sessionId) {
  return this.findOne({ sessionId }).sort({ chapterIndex: -1 });
};

chapterSchema.statics.getChapterCount = function(sessionId) {
  return this.countDocuments({ sessionId });
};

// Instance methods
chapterSchema.methods.updateChoice = function(choiceIndex, nextChapterId) {
  if (choiceIndex >= 0 && choiceIndex < this.choices.length) {
    this.choices[choiceIndex].nextChapterId = nextChapterId;
    this.updatedAt = new Date();
    return this.save();
  }
  throw new Error('Invalid choice index');
};

chapterSchema.methods.addChoice = function(text) {
  if (this.choices.length >= 4) {
    throw new Error('Maximum 4 choices allowed per chapter');
  }
  this.choices.push({ text, nextChapterId: null });
  this.updatedAt = new Date();
  return this.save();
};

chapterSchema.methods.removeChoice = function(choiceIndex) {
  if (choiceIndex >= 0 && choiceIndex < this.choices.length) {
    this.choices.splice(choiceIndex, 1);
    this.updatedAt = new Date();
    return this.save();
  }
  throw new Error('Invalid choice index');
};

chapterSchema.methods.isRecent = function(minutes = 60) {
  const now = new Date();
  const diffInMinutes = (now - this.createdAt) / (1000 * 60);
  return diffInMinutes <= minutes;
};

// Pre-save middleware to update updatedAt
chapterSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  next();
});

// Export the model
export const Chapter = mongoose.models.Chapter || model('Chapter', chapterSchema);
